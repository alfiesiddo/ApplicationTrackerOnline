@model List<ApplicationTrackerOnline.Models.JobApplication>
@{
    ViewData["Title"] = "Your Applications";

    var orderedApplications = Model
        .OrderBy(a => a.Status)
        .ThenBy(a => a.AppliedDate);
}

<div class="text-center my-4">
    <h1 class="display-4">@ViewData["Title"]</h1>
</div>

<div class="d-flex justify-content-center gap-2 mb-4 flex-wrap">
    <a class="btn btn-dark" asp-controller="Home" asp-action="AddApplication">
        Add Application
    </a>

    <select id="statusFilter" class="form-select" style="width: auto;">
        <option value="all">Show All</option>
        <option value="1">Applied</option>
        <option value="0">Rejected</option>
        <option value="2">Scouted</option>
        <option value="3">Assessments</option>
        <option value="4">Interview</option>
        <option value="5">Offered</option>
    </select>
</div>

@Html.AntiForgeryToken()

<div class="container">
    <div class="row justify-content-center g-4" id="application-list">
        @foreach (var app in orderedApplications)
        {
            <div class="col-12 col-md-10 col-lg-8 d-flex justify-content-center"
                 data-status="@app.Status"
                 data-job-id="@app.Id">
                <div class="w-100" style="max-width: 900px;">
                    @await Html.PartialAsync("_JobApplicationCard", app)
                </div>
            </div>
        }
    </div>
</div>

<!-- Existing script for status updates (small robust update to locate job id) -->
<script>
    (function () {
        const STATUS_MAP = {
            1: { label: "Applied", cls: "status-applied" },
            0: { label: "Rejected", cls: "status-rejected" },
            2: { label: "Scouted", cls: "status-scouted" },
            3: { label: "Assessments", cls: "status-assessments" },
            4: { label: "Interview", cls: "status-interview" },
            5: { label: "Offered", cls: "status-offered" }
        };

        function getAntiForgeryToken() {
            const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
            return tokenInput ? tokenInput.value : null;
        }

        async function updateStatusOnServer(jobId, newStatus) {
            const url = '/Home/UpdateApplicationStatus';
            const token = getAntiForgeryToken();
            const payload = { id: jobId, status: parseInt(newStatus, 10) };
            const headers = { 'Content-Type': 'application/json' };
            if (token) headers['RequestVerificationToken'] = token;

            const resp = await fetch(url, {
                method: 'POST',
                headers,
                body: JSON.stringify(payload),
                credentials: 'same-origin'
            });

            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `Server responded ${resp.status}`);
            }
            // NOTE: you currently reload the page after update. If you'd like
            // the UI to remain fully "optimistic" without reload, remove the
            // `location.reload()` line and rely on the returned result below.
            location.reload();
            return await resp.json();
        }

        function setBadge(jobId, statusInt) {
            const toggle = document.getElementById('status-toggle-' + jobId);
            const badgeLabel = toggle && toggle.querySelector('.status-label');
            if (!toggle || !badgeLabel) return;
            const map = STATUS_MAP[statusInt] || { label: 'Unknown', cls: 'status-unknown' };
            badgeLabel.textContent = map.label;

            // remove previous status-* classes but keep other classes
            toggle.className = 'status-badge ' + map.cls;
        }

        function openMenu(dropdown, toggle, menu) {
            menu.removeAttribute('hidden');
            toggle.setAttribute('aria-expanded', 'true');
            const current = menu.querySelector('.status-item.current');
            (current || menu.querySelector('.status-item')).focus();
            document.addEventListener('click', dropdown._outsideHandler = (ev) => {
                if (!dropdown.contains(ev.target)) closeMenu(dropdown, toggle, menu);
            });
            document.addEventListener('keydown', dropdown._keyHandler = (ev) => menuKeyHandler(ev, dropdown, toggle, menu));
        }

        function closeMenu(dropdown, toggle, menu) {
            menu.setAttribute('hidden', '');
            toggle.setAttribute('aria-expanded', 'false');
            if (dropdown._outsideHandler) {
                document.removeEventListener('click', dropdown._outsideHandler);
                dropdown._outsideHandler = null;
            }
            if (dropdown._keyHandler) {
                document.removeEventListener('keydown', dropdown._keyHandler);
                dropdown._keyHandler = null;
            }
        }

        function toggleMenu(dropdown, toggle, menu) {
            const isOpen = toggle.getAttribute('aria-expanded') === 'true';
            if (isOpen) closeMenu(dropdown, toggle, menu);
            else openMenu(dropdown, toggle, menu);
        }

        function menuKeyHandler(e, dropdown, toggle, menu) {
            const active = document.activeElement;
            const items = Array.from(menu.querySelectorAll('.status-item'));
            const idx = items.indexOf(active);
            if (e.key === 'Escape') {
                e.preventDefault();
                closeMenu(dropdown, toggle, menu);
                toggle.focus();
                return;
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                const next = items[(idx + 1) % items.length];
                next.focus();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                const prev = items[(idx - 1 + items.length) % items.length];
                prev.focus();
            } else if (e.key === 'Home') {
                e.preventDefault();
                items[0].focus();
            } else if (e.key === 'End') {
                e.preventDefault();
                items[items.length - 1].focus();
            } else if (e.key === 'Tab') {
                closeMenu(dropdown, toggle, menu);
            } else if (e.key === 'Enter' || e.key === ' ') {
                if (active && active.classList.contains('status-item')) {
                    e.preventDefault();
                    active.click();
                }
            }
        }

        document.querySelectorAll('.status-dropdown').forEach(dropdown => {
            const toggle = dropdown.querySelector('.status-badge');
            const menu = dropdown.querySelector('.status-menu');

            // Robustly find the containing job id: look for nearest ancestor with data-job-id
            const jobAncestor = dropdown.closest('[data-job-id]');
            const jobId = jobAncestor ? jobAncestor.getAttribute('data-job-id') : null;

            if (!toggle || !menu || !jobId) return;

            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu(dropdown, toggle, menu);
            });

            toggle.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    openMenu(dropdown, toggle, menu);
                }
            });

            menu.querySelectorAll('.status-item').forEach(item => {
                item.addEventListener('click', async (ev) => {
                    const selectedValue = item.getAttribute('data-value');
                    setBadge(jobId, selectedValue);
                    menu.querySelectorAll('.status-item').forEach(i => i.classList.remove('current'));
                    item.classList.add('current');

                    closeMenu(dropdown, toggle, menu);
                    toggle.focus();

                    try {
                        const result = await updateStatusOnServer(jobId, selectedValue);
                        if (result && typeof result.status !== 'undefined') {
                            setBadge(jobId, result.status);
                            menu.querySelectorAll('.status-item').forEach(i => {
                                i.classList.toggle('current', i.getAttribute('data-value') == result.status);
                            });
                        }
                    } catch (err) {
                        alert('Could not update status on server. Please try again.');
                        console.error(err);
                    }
                });
            });

            menu.querySelectorAll('.status-item').forEach(i => i.setAttribute('tabindex', '-1'));
        });
    })();
</script>

<!-- Script for handling dropdown filtering (fixed to select elements with data-status) -->
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const statusFilter = document.getElementById('statusFilter');
        const applicationList = document.getElementById('application-list');

        // Select all elements inside #application-list that carry data-status
        const allApplications = applicationList.querySelectorAll('[data-status]');

        statusFilter.addEventListener('change', function () {
            const selectedStatus = this.value;

            allApplications.forEach(function (card) {
                const cardStatus = card.getAttribute('data-status');
                if (selectedStatus === 'all' || cardStatus === selectedStatus) {
                    card.style.display = ''; // show
                } else {
                    card.style.display = 'none'; // hide
                }
            });
        });
    });
</script>
